# 1장 함수형 프로그래밍이란?

## 1.1 함수형 프로그래밍의 특징

- 함수를 사용해서 데이터처리의 참조 투명성을 보장하고 상태와 가변 데이터 생성을 피하는 프로그래밍 패러다임
- 특징
    - 불변성
    - 참조 투명성
    - 일급 함수
    - 게으른 평가
- 이점
    - 부수효과가 없는 프로그램 → 동시성 프로그래밍에 적합
    - 간결한 코드 → 모듈성이 높아져 유지보수가 용이
    - 프로그램의 예측성 상승 → 컴파일러가 효율적으로 실행되는 코드

## 1.2 순수한 함수란 무엇인가?

- 특징
    - 동일한 입력으로 실행하면 항상 동일한 결과가 나온다
    - 부수효과가 없다

### 동일 입력 동일 출력

- 결과에 대한 추론이 가능하고 테스트도 용이
- 컴파일 타임에 코드를 최적화하거나 오류 코드를 예측하고 경고 가능
- 동시성 프로그래밍에서는 공유 자원이 변경될 걱정 없이 더 안전한 프로그램 개발 가능
- 참조 투명성 만족

### 부수효과 없는 코드

- 부수효과란, 함수가 실행되는 과정에서 외부의 상태를 사용 또는 수정하는 것을 의미
    - 전역 변수나 정적 변수를 수정하거나
    - 파일이나 네트워크를 출력하는 작업 등
    - 예외 발생

## 1.3 부수효과 없는 프로그램 작성하기

- 부수효과는 함수의 반환값이 아닌, 외부의 상태에 영향을 미치는 것을 의미
    - 불확실성은 많은 노이즈 코드([Boilerplate Code])를 생성하고 프로그램을 복잡하게 만듬
        - *Boilerplate Code란, 최소한의 변경으로 여러곳에서 재사용되며, 반복적으로 비슷한 형태를 띄는 코드*
    - 디버깅과 테스트를 어렵게 하고, 버그를 만들기 쉽게 함

### 공유 변수 수정으로 인한 부수효과

- 함수 내에서 전역 변수와 같은 공유 변수를 수정하면 부수효과가 발생
이 변수를 참조하는 변수는 결과가 외부 요인에 의해 변경
- 이러한 결괏값의 변화는 프로그래머가 예측하지 못한 것일 수 있으며,
예측했더라도 이런 식으로 외부 변수를 변경하는 건 좋지 않음
- 변수의 상태를 예측하기 어렵기 때문에
해당 변수를 사용하는 다른 함수에서 예외처리가 필요할 수 있음

### 객체의 상태 변경으로 인한 부수효과

- 다른 함수나 모듈에서 동일 인스턴스를 참조하면 부수효과의 영향을 받음
- 부수효과를 없애기 위해서는 가변적 객체를 불변적 객체로 수정
- 값의 수정에 영속성이 있어야 할 경우가 있기에 DB에 넣는다면 부수효과가 발생할 수 있음
    - 부수효과를 수반해야만 하는 작업은 반드시 순수한 영역과 분리
    - 분리된 영역이 외부로 드러나지 않도록 설계

## 1.4 참조 투명성으로 프로그램을 더 안전하게 만들기

- 참조 투명성이란, 프로그램의 변경 없이 어떤 표현식을 값으로 대체할 수 있다는 의미
    - 수학의 개념으로 예시를 들면 `1+1`은 `2`로 대체 가능
    - 동일한 입력에 대해서 동일한 결과를 돌려주는 경우
    - 참조 투명성은 프로그래머나 컴파일러가 평가 결과를 추론할 수 있게 함
        - 프로그램이 실행되기 전에 컴파일러가 코드를 최적화하거나 코드가 평가되는 시점을 늦출 수 있음
        - 코드에 예외가 사라져서 간결해지고 버그가 발생할 가능성이 낮아짐
        - 멀티스레드 코드에서 스레드 안정성에 대한 고민을 줄임
- 참조 투명하지 않은 함수
    ```kotlin
    var someName: String = "Joe"

    // 외부 변수를 참조하여 출력하고 있기 때문에 부수효과 발생
    fun hello1() {
        println("Hello $someName")
    }

    // 콘솔에 출력하는 작업자체가 여전히 부수효과 발생
    fun hello2(name: String) {
        println("Hello $name")
    }
    ``` 
- 참조 투명한 함수
    ```kotlin
    fun main(args: Array<String>) {
        val result = transparent("Joe")
        print(result)
    }

    // 참조에 투명한 함수
    // 언제 어디서 호출해도 문제가 없어서 재사용성이 높고, 테스트하기 쉬움
    fun transparent(name: String): String {
        return "Hello $name"
    }

    // 여전히 부수효과 발생, 하지만 프로그램 요구사항을 만족시키기 위해 불가피한 부분
    fun print(str: String) {
        println(str)
    }
    ``` 

> 💡 값을 매개변수로 받는 것으로도 충분하다고 생각됨  
> ’인사말을 화면에 출력하라’라는 프로그램 요구사항을 만족시키기 위해서 불가피한 부분이라는데, 불가피한 부분을 얼마나 최소화할 것인가? 의 고민  
> 저자는 부수효과를 일으키는 영역과 순수한 영역을 되도록 분리하고 참조에 투명한 함수들로 구성하는 것을 추천

## 1.5 일급 함수란?

### 일급 객체 (First-Class Object)

- 다음 세 가지 조건을 만족시키는 객체를 의미 (ex. Kotlin의 최상위 객체인 Any)
    - 객체를 함수의 매개변수로 넘길 수 있다.
        ```kotlin
        fun doSomethingWithAny(any: Any) {
            // do Something
        }
        ```
    - 객체를 함수의 반환 값으로 돌려줄 수 있다.
        ```kotlin
        fun doSomethingWithAny(): Any {
            // do Something
        }
        ```
    - 객체를 변수나 자료구조에 담을 수 있다.
        ```kotlin
        var anyList: List<Any> = listOf(Any())
        ```

### 일급 함수 (First-Class Function)

- 동일한 조건들을 함수에 적용했을 때, 다음 조건들을 만족하는 함수가 일급 함수
    - 함수를 함수의 매개변수로 넘길 수 있다.
        ```kotlin
        fun doSomething(func: (Int) -> String) {
            // do Something
        }
        ```
    - 함수를 함수의 반환 값으로 돌려줄 수 있다.
        ```kotlin
        fun doSomething(): (Int) -> String {
            return { value -> value.toString() }
        }
        ```
    - 함수를 변수나 자료구조에 담을 수 있다.
        ```kotlin
        var funcList: List<(Int) -> String> = listOf({ value -> value.toString() })
        ```

일급 함수를 통해서 더 높은 추상화가 가능하고, 코드의 재사용성을 높임

## 1.6 일급 함수를 이용한 추상화와 재사용성 높이기

### 간단한 계산기 예제

```kotlin
fun main(args: Array<String>) {
    val calculator = SimpleCalculator()
    println(calculator.calculate('+', 3, 1)) // "4"
    println(calculator.calculate('-', 3, 1)) // "2"
}

class SimpleCalculator {
    fun calculate(operator: Char, num1: Int, num2: Int): Int = when (operator) {
        '+' -> num1 + num2
        '-' -> num1 - num2
        else -> throw IllegalArgumentException()
    }
}
```
- 기능을 추가하려면 함수가 변경되어야 하고, 함수가 변경되면 기존 기능에 영향을 줄 수 있음
- 기능 간의 결합도가 높고, 응집도가 낮아 좋지 않은 코드
    > **결합도와 응집도란?**
    > 결합도, 프로그램의 어떤 구성요소가 다른 요소에 얼마나 의존하는가  
        - 기능 간 또는 모듈 간의 의존도가 낮아 잘 분리되어 있으면 결합도가 낮음  
        - 결합도가 높으면 특정 모듈이 변경되면 연관된 다른 모듈이 같이 변경되어야 함  
    > 응집도, 프로그램의 어떤 구성요소가 동작하기 위해서 얼마만큼 관련된 기능들만으로 묶여있는가  
        - 기능 구현에 필요한 연관 기능들이 잘 모여있고, 너무 많은 일을 하지 않으면 응집도가 높음  
    > 결합도가 낮고 응집도가 높아야 잘 설계된 프로그램
- 기능의 확장성이 고려되지 않았고, 다른 프로그램에서 재사용하기 어려움

### 객체지향적으로 개선한 계산기 예제

```kotlin
fun main(args: Array<String>) {
    val plusCalculator = OopCalculator(Plus())
    println(plusCalculator.calculate(3, 1))     // "4"

    val minusCalculator = OopCalculator(Minus())
    println(minusCalculator.calculate(3, 1))    // "2"
}

interface Calculator {
    fun calculate(num1: Int, num2: Int): Int
}

class Plus: Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 + num2
    }
}

class Minus: Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 - num2;
    }
}

class OopCalculator(private val calculator: Calculator) {
    fun calculate(num1: Int, num2: Int): Int = calculator.calculate(num1, num2)
}
```

- 이전 코드에 비해 결합도가 낮아지고 응집도가 높아짐
- 기능이 추가된다면 해당하는 객체를 생성하고 주입하면 되서 기존 로직에 영향이 없음
- 이러한 코드의 장점
    - 기능 추가 및 변경 시, 관련없는 모듈을 수정할 필요가 없고 내부에 대해서 알 필요도 없음
    - 인터페이스를 이용해 기능을 쉽게 확장할 수 있음
    - 클래스나 함수들이 한 가지 일만 하기 때문에 코드 재사용성이 높음
    - 의존성 주입 덕분에 테스트하기 쉬움

### **함수형 프로그래밍 방식으로 개선한 계산기 예제**

```kotlin
fun main(args: Array<String>) {
    val fpCalculator = FpCalculator()

    println(fpCalculator.calculate({ n1, n2 -> n1 + n2 }, 3, 1))    // "4"
    println(fpCalculator.calculate({ n1, n2 -> n1 - n2 }, 3, 1))    // "2"
}

class FpCalculator {
    fun calculate(calculator: (Int, Int) -> Int,
                  num1: Int, num2: Int): Int = calculator(num1, num2)
}
```

- 중요한 로직을 추상화하여 람다표현식으로 매개변수로 전달
- 비즈니스 로직을 구현하기 위한 인터페이스와 구현 클래스를 전부 제거
- 기능을 추가하려면, 입출력 타입만 동일하다면 별도의 클래스 추가 없이 계산기능을 추가 가능

## 1.7 **게으른 평가로 무한 자료구조 만들기**

- 일반적으로 명령형 언어는 코드가 실행되는 즉시 값이 평가(Eager)
함수형 언어는 기본적으로 값이 필요한 시점에 평가(Lazy), 프로그래머가 평가 시점을 지정 가능
    - 값이 실제로 필요한 시점까지 실행하지 않기 때문에
    시간이 오래 걸리는 작업을 효율적으로 동작 가능
- 코틀린에서 제공하는 문법인 `by lazy` 활용 (변수를 `by lazy`로 선언하고 매개변수로 람다식 전달)
    - 변수를 선언하는 시점에 람다식을 실행하지 않고, 실제로 호출되는 시점에 람다식을 실행
    - 또한 여러번 호출되더라도 최초에 한 번만 평가를 실행
    내부적으로 결과값을 저장해두고 필요할 때 가져옴
    - 값이 한 번만 평가되기 때문에 값을 바꿀 수 없음

### **무한대 값을 자료구조에 담다**

- 명령형 언어에서는 불가능
함수형 언어에서는 게으른 평가라는 특성을 활용해서 무한대 값을 자료구조에 저장 가능

[Boilerplate Code]: https://charlezz.medium.com/%EB%B3%B4%EC%9D%BC%EB%9F%AC%ED%94%8C%EB%A0%88%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%9E%80-boilerplate-code-83009a8d3297
