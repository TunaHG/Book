# 2장 코틀린으로 함수형 프로그래밍 시작하기

## 2.1 **프로퍼티 선언과 안전한 널 처리**

### **프로퍼티 선언**

- 읽기 전용 프로퍼티(`val`)와 가변 프로퍼티(`var`)를 구별해서 선언 가능
- 코틀린은 프로퍼티의 값을 보고 타입을 추론할 수 있음
코드가 복잡하다면 가독성을 위해 타입을 의도적으로 명시하는 것을 추천

### **안전한 널 처리**

- 타입 뒤에 `?`를 붙이면 해당 프로퍼티는 값으로 `null`을 할당 가능
- `?`가 없이 선언된 프로퍼티에 `null`을 할당하면 컴파일 오류가 발생

## 2.2 **함수와 람다**

### **함수를 선언하는 다양한 방법**

- 함수의 예약어는 `fun`, 프로퍼티 선언 구조와 유사
- 코드 블록 `{}`과 `return`을 모두 사용하면 프로퍼티와 다르게 타입 추론을 하지 않기 때문에
함수의 반환 타입을 항상 명시해야 함. 명시하지 않으면 `Unit`을 반환
    - `Unit`은 Java의 `void`와 유사한 의미
    `void`는 원시형 타입이지만, `Unit`은 참조형 타입으로 객체가 선언되어 있음
- 코드 블록과 `return`을 생략하고 프로퍼티 선언과 유사하게 `=` 연산자로 선언 가능
    - 타입 추론이 가능하기 때문에 반환 타입 선언을 생략 가능

### **매개변수에 기본값 설정하기**

- 호출할 때 매개변수를 생략하면 기본값이 할당
다만, 매개변수의 순서에 따라서 값이 할당된다는 점에 주의
- 호출할 때 매개변수 명을 지정하여 호출 가능

### **익명 함수와 람다 표현식**

- 익명 함수는 함수 이름을 선언하지 않고, 구현부만 작성하는 함수를 표현하는 방식의 일종
- 람다식 내에서 변수의 타입은 선언되지 않았지만, 컴파일러가 타입선언을 참고하여 추론
- 주의할 점은 람다식은 평가되지 않고 이름으로만 할당된다는 점
    - 람다식에서 `return`을 사용하지 않으면 마지막 라인의 결과가 반환

### **확장 함수**

- 상속을 하거나 내부를 수정하지 않고도 이미 작성된 클래스에 함수나 프로퍼티 추가 가능
- 확장 함수는 별도의 인자를 받지 않고도 this를 사용해서 자기 자신의 값에 접근 가능

## 2.3 **제어 구문**

### **if문**

- 코틀린에서 `if`문은 기본적으로 표현식
표현식은 구문과 달리 결과로서 어떤 값을 반환
    - 결과값을 반환할 때는 표현식으로, 결과값이 없을 때는 구문으로 사용됨
- `if`문을 표현식으로 사용할 때는 반드시 `else`가 필요, 없으면 컴파일 오류 발생

### **when문**

- Java의 `switch`문과 유사한 기능
- 위에서부터 차례대로 매칭되며, 복수의 값에 대한 조건을 만들 때는 `,`로 구분하여 나열
- 함수의 실행 결과도 매칭 가능
- 분기 조건을 조건문으로 작성 가능
    - 조건문을 표현식으로 직접 넣을 때는 `when (x)`에서 `(x)`를 생략

### **for문**

- 컬렉션에서 아이템을 하나씩 꺼내서 처리하려면 `in`
- 아이템과 인덱스를 한꺼번에 꺼내고 싶다면 `withIndex()` 활용
- 범위 및 증감 규칙 설정 가능
    - `in 1..3`를 활용하여 범위 지정 (이하의 값 → 123)
    - `until 1..3`를 활용하여 범위 지정 (미만의 값 → 12)
    - `in 6 downTo 0 step 2`를 활용하여 범위와 증감규칙 지정 (6420)

## 2.4 **인터페이스**

### **인터페이스의 특징**

- 다중 상속이 가능
- 추상 함수를 가질 수 있음
- 함수의 본문을 구현 가능
- 여러 인터페이스에서 같은 이름의 함수를 가질 수 있음
- 추상 프로퍼티를 가질 수 있음

### **인터페이스 선언하고 상속하기**

- 선언할 때는 자바와 동일한 `interface` 키워드로 사용
- 코틀린에서는 `:`로 상속을 표현
- 여러 개의 인터페이스를 상속하기 위해 `,`를 구분자로 사용

### **인터페이스에 추상 함수 선언하기**

- 추상 함수란, 해당 인터페이스를 상속한 클래스가 구현할 동작을 정의한 함수를 의미
- 상속한 클래스에서 인터페이스의 추상 함수를 재정의할 때는 `override` 키워드를 사용

### **추상 함수 구현하기**

- 인터페이스에 함수의 본문이 작성된 추상 함수는 상속한 클래스에서 추상 함수를 구현하지 않아도 됨
- 상속한 클래스에서 중복 작성된 경우는 클래스에서 작성한 추상 함수가 실행
- 다중 상속하여 동일한 이름을 가진 추상 함수의 경우
상속한 클래스에서 상속받은 인터페이스의 함수를 `super<Interface>.method()`의 형태로 사용

### **추상 프로퍼티의 선언과 사용**

- 추상 프로퍼티란, 해당 인터페이스를 상속한 클래스가 가질 프로퍼티를 의미
- 추상 프로퍼티를 상속한 클래스에서 재정의 할 때도 `override` 키워드 사용
- 추상 함수와 달리 인터페이스에서는 추상 프로퍼티의 값을 직접 초기화할 수 없고 `get()`를 구현
    - 인터페이스에서 이미 초기화된 추상 프로퍼티는 상속한 클래스에서 초기화하지 않아도 됨

## 2.5 **클래스**

### **클래스와 프로퍼티**

- 새로운 객체를 생성할 때 `new` 연산자를 사용하지 않음
- 프로퍼티는 Java의 멤버변수와 달리 `getter`와 `setter`를 내부에서 자동으로 생성
    - `var`로 선언된 프로퍼티는 `getter`, `setter` 모두 사용 가능
    - `val`로 선언된 프로퍼티는 `getter`만 사용 가능
- 함수와 동일하게 클래스 생성자에 프로퍼티의 기본값 할당 가능

### **data 클래스**

- 기본적으로 `getter`, `setter` 함수를 생성해주고 
`hashCode`, `equals`, `toString` 함수 자동 생성

### **enum 클래스**

- 동일한 타입의 프로퍼티와 함수를 가진 이름들을 정의하여 사용 가능
- 프로퍼티와 함수가 모두 타입이 동일해야 한다는 제약

### **sealed 클래스**

- 제약 없이 새로운 타입을 확장할 수 있는 클래스
- enum 클래스의 확장 형태로 클래스를 묶은 클래스
- 서로 다른 프로퍼티와 함수를 가진 이름(class or obejct)들을 가질 수 있음
- 단, sealed 클래스를 상속하는 각 하위 클래스는 sealed 클래스와 동일한 파일에서만 선언 가능
- when에서 활용할 때
    - 상속하는 각 하위 클래스들의 케이스가 모두 존재해야 컴파일 오류가 안남

## 2.6 **패턴 매칭**

패턴 매칭이란, 값, 조건, 타입 등의 패턴에 따라서 매칭되는 동작을 수행하게 하는 기능

### **다양한 패턴 정의 방법**

- when 문에 값을 넣어서 사용하면, 값에 따른 패턴 매칭을 정의 가능

### **조건에 따른 패턴 매칭**

- when 문에 값을 넣지 않으면, 조건문에 따른 패턴을 정의 가능
- `===`은 객체의 참조 값을 비교하고 `==`은 객체의 값을 비교, `is`는 객체의 타입을 비교

### **코틀린 패턴 매칭의 제약**

- 리스트와 같은 매개변수를 포함하는 타입이나 함수의 타입에 대한 패턴 매칭을 지원하지 않음

## 2.7 **객체 분해**

객체 분해란, 어떤 객체를 구성하는 프로퍼티를 분해하여 편리하게 변수에 할당하는 것을 의미

- 객체를 하나씩 받아와서 각 프로퍼티들을 생성하고 변수에 직접 할당하는 작업이 불필요
- 일부만 변수로 할당하고 나머지는 무시하고 싶다면 `_`를 사용
- 객체 분해는 리스트뿐만 아니라 맵 등의 다양한 컬렉션에서도 사용 가능

## 2.8 **컬렉션**

- 코틀린에서는 불변과 가변 자료구조를 분리해서 제공
- List, Set, Map 등의 자료구조는 기본적으로 불변
가변 자료구조는 Mutable을 접두사로 붙인 별도의클래스로 제공

### **리스트와 세트**

- 리스트는 비어 있거나 동일한 타입의 값들을 여러 개 넣을 수 있는 자료구조
    - `listOf()`
- 세트는 동일한 타입의 값들을 여러 개 넣을 수 있다는 점에서 리스트와 유사하나,
중복 값이 들어갈 수 없다는 점에서 다름
    - `setOf()`
- `plus` 함수는 원본 리스트를 변경하지 않고 새로운 리스트를 반환

### **맵**

- 코틀린에서는 키와 값을 가진 자료구조인 `Pair`를 제공
    - `Pair`는 생성자를 호출하거나 `to`와 같이 코틀린에서 제공하는 문법을 활용하여 생성
- 맵은 키와 값인 Pair를 여러 개 가진 자료구조

## 2.9 **제네릭**

- 객체 내부에서 사용할 데이터 타입을 외부에서 정하는 기법
- 제네릭을 사용하면 클래스를 선언할 때 타입을 확정 짓지 않고, 클래스가 객체화되는 시점에 타입이 결정
- 제네릭을 사용해 클래스를 일반화하면 재사용성이 높아짐
    - 마찬가지로 함수의 타입을 일반화하면 재사용성이 높은 함수를 생성 가능

### **제네릭 함수 선언**

- `fun <T> metho(list: List<T>): T { }`

## 2.10 **코틀린 표준 라이브러리**

- 간결하고 명료한 코드를 작성하는 데 도움을 주는 확장 함수들을 제공

### **let 함수**

- `fun <T, R> T.let(block: (T) → R): R`
- 함수를 사용하면 어떤 객체의 상태를 변경할 수 있음
- 입력받은 `block` 함수에서는 `it`을 사용해서 객체에 접근

### **with 함수**

- `fun <T, R> with(receiver: T, block: T.() → R): R`
- `T.()`를 람다 리시버라고 함. 
이렇게 전달받으면 block 함수에서 receiver로 받은 객체에 this를 사용하지 않고 접근 가능
- `let` 함수와 동일하게 어떤 객체의 상태를 변경하는 데 활용

### **run 함수**

- `fun <T, R> T.run(block: T.() → R): R`
    - 확장 함수이기 때문에 객체로부터 연속적으로 호출 가능
    - 람다 리시버로 받았기 때문에 `it`이나 `this`없이 객체의 프로퍼티에 접근 가능
- `fun <R> run(block: () → R): R`
    - 어떤 객체로부터 연결되는 블록을 수행하기 위한 함수가 아님
    - 어떤 객체를 생성하기 위한 명령문을 하나의 블록으로 묶는 용도로 사용

### **apply 함수**

- `fun <T> T.apply(block: T.() → Unit): T`
- `T`의 확장 함수이므로 `apply` 함수는 객체를 통해서 호출
- `block` 함수 내에서 객체 자체를 수정하고 
반환값이 없기 때문에 객체의 타입 자체를 다른 타입으로 바꾸어 반환할 수 없음
- 객체만 변경할 때는 반환값을 명시하지 않아도 되기 때문에 다른 함수보다 사용에 적합함

### **also 함수**

- `fun <T> T.also(block: (T) → Unit): T`
- `apply` 함수와 동일하게 객체 자체를 변경할 때만 사용

### **함수 비교**

- 선언 형태나 사용법이 거의 유사하며
라이브러리를 사용하는 목적도 코드를 간결하게 하기 위함으로 모두 같음
- 하지만 작업 내용에 따라서 코드를 가장 간결하게 할 수 있는 라이브러리는 존재

### **use 함수**

- 클로저블 객체는 자원을 사용한 후 클로즈해야 함.
`use`는 클로즈 작업을 자동으로 해 주는 함수
- Java의 `try-with-resourece`와 동일한 기능

## 2.11 **변성**

- 제네릭을 포함한 타입의 계층 관계에서 타입의 가변성을 처리하는 방식
- 타입 S가 T의 하위 타입일 때, Box[S]가 Box[T]의 하위 타입인가? 라는 질문에서 시작
    - Box[S]와 Box[T]는 상속 관계가 없다 → 무공변
    - Box[S]는 Box[T]의 하위 타입이다 → 공변
    - Box[T]는 Box[S]의 하위 타입이다 → 반공변
    - 동일한 방향의 상하위 관계면 공변, 반대면 반공변, 관계가 없으면 무공변으로 이해

### **무공변의 의미와 예**

- 타입 S가 T의 하위 타입일 때, Box[S]와 Box[T] 사이에 상속 관계가 없는 것을 의미

### **공변의 의미와 예**

- 타입 S가 T의 하위 타입일 때, Box[S]가 Box[T]의 하위 타입인 것을 의미
- 코틀린에서는 공변을 `<out T>`로 선언
- Java에서는 공변을 upper bound `<? extends T>`로 선언

### **반공변의 의미와 예**

- 타입 S가 T의 하위 타입일 때, Box[S]가 Box[T]의 상위 타입인 것을 의미
- 코틀린에서는 반공변을 `<in T>`로 선언
- Java에서는 공변을 lower bound `<? super T>`로 선언

### **in, out으로 변성 선언하기**

- 코틀린에서는 변성을 `in`, `out` 키워드를 사용해서 선언
- 타입 매개변수를 이렇게 선언하면, 기본적으로 변성을 가지게 될 뿐만 아니라
타입 매개변수에 대한 몇 가지 정보를 컴파일러에 알려 줌