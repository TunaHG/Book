# 2장 학습

## 1. 가능하면 적게 캡슐화하세요

4개 또는 그 이하의 객체를 캡슐화할 것을 권장한다.
~~세계 안의 객체를 바라보는 우리의 사고방식으로 4개 이상의 요소로 구성된 조표를 이해하는 것은 너무나도 어렵다.~~

더 많은 객체가 필요하다면, 클래스를 더 작은 클래스들로 분해해야 한다.

## 2. 최소환 뭔가는 캡슐화하세요

너무 많이 캡슐화하는 방식도 좋지 않지만, 아무것도 캡슐화하지 않는 방식 또한 바람직하지 않다.

객체가 자기 자신을 식별할 수 있도록 다른 객체들을 캡슐화해야 한다.

## 3. 항상 인터페이스를 사용하세요

객체들이 서로를 필요로 하기 때문에 결합된다.

애플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 분리해야한다.
**객체 분리**란, 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것이다.
이를 가능하게 하는 가장 훌륭한 도구가 **인터페이스**다.

인터페이스는 우리의 객체가 다른 객체와 의사소통하기 위해 따라야하는 계약이다.

클라이언트에서는 인터페이스의 구현 방법에 아무런 관심이 없다.
이는 인터페이스를 이용하면 클라이언트와 구현체를 느슨하게 분리할 수 있다는 의미다.
구현체의 내부 구현을 변경하거나 인터페이스의 다른 구현체로 변경하더라도 클라이언트에는 아무 영향이 없다.

## 4. 메소드 이름을 신중하게 선택하세요

빌더(Builder)의 이름은 명사로, 조정자(Manipulator)의 이름은 동사로 짓는 것을 추천한다.
빌더는 어떤 것을 만들고, 조정자는 무언가를 조작한다.

빌더란, 무언가를 만들고 새로운 객체를 반환하는 메소드를 가리킨다.
항상 무언가를 반환하기 때문에 반환타입이 절대 void가 될 수 없으며, 이름은 항상 명사여야 한다.

조정자란, 객체로 추상화한 실세계 엔티티를 수정하는 메소드를 의미한다.
조정자의 반환타입은 항상 void이고, 이름은 항상 동사이다.

객체에게 어떤 일을 해야 하는 지를 직접적으로 이야기하지 않는다. 특정한 계약을 준수하는 결과를 요청할 뿐이다

## 5. 퍼블릭 상수를 사용하지 마세요

객체들은 어떤 것도 공유해서는 안된다. 대신 독립적이어야 하고 닫혀있어야 한다.
상수를 이용한 공유 메커니즘은 캡슐화에 객체지향적인 사고 전체를 부정하는 일이다.

코드 중복이라는 문제를 해결하기 위해 결합도가 높아지고, 응집도가 낮아지는 두 개의 문제가 발생한다.
결합도 UP → 상수가 변경될 경우 사용되는 부분이 전부 변경되어야 한다.
응집도 DOWN → 목적을 명확하게 만들어줄 코드를 추가해서 상수를 감싸야 할 수 있다.

상수를 사용하지 않고 새로운 클래스를 사용하여 문제를 해결할 수 있다.
둘의 코드가 다르지 않다고 생각할 수 있지만, 새로운 클래스에 대한 결합은 계약을 통해 추가된 것이며
계약에 의한 결합은 언제라도 분리가 가능하기 때문에 유지보수성을 저하시키지 않는다.

## 6. 불변 객체로 만드세요

모든 클래스를 상태 변경이 불가능한 불변 클래스로 구현하면 유지보수성을 크게 향상시킬 수 있다.
불변성은 크기가 작고, 응집력이 높으며, 느슨하게 결합되고, 유지보수하기 쉬운 클래스를 만들 수 있도록 한다.

불변 객체는 어떤 방식으로든 자기 자신을 수정할 수 없다.

불변성을 지지하는 이유

1. 식별자 가변성 문제가 없다.
동일해 보이는 두 객체를 비교한 후 한 객체의 상태를 변경할 때,
두 객체는 더 이상 동일하지 않지만 우리는 여전히 두 객체가 동일하다고 생각하는 문제
불변 객체를 사용하면 객체를 map에 추가한 후에는 상태 변경이 불가능하기 때문에 문제가 발생하지 않는다.
2. 실패 원자성 → 완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성이다.
객체의 상태 변경중 Exception이 발생하면 객체의 일부만 변경되고 나머지는 원래 값을 유지할 수 있다.
불변 객체는 내부의 어떤 것도 수정할 수 없기 때문에 이런 결함이 발생하지 않는다.
대신 새로운 상태를 가진 새로운 객체를 인스턴스화한다.
3. 시간적 결합을 제거할 수 있다.
어떤 이유에서든 코드를 재정렬하기로 결정했다면, 코드를 수정하기 전에 우선 코드 줄 사이의 시간적인 결합을 이해해야 한다.
가변 객체의 수가 많은 상황에서 가변 객체들을 처리하는 연산들의 순서를 일일이 기억해야 한다면 유지보수가 어려울 것이다.
불변 객체를 사용하면 인스턴스화와 초기화를 분리시킬 수 없고 항상 함께 실행되어야 한다.
4. 사이드이펙트 제거
불변 객체를 사용하면 어떤 누구도 객체를 수정할 수 없어서 객체의 상태가 변하지 않았다고 확신할 수 있다.
코드가 제대로 동작하지 않는 경우에도 사이드이펙트가 발생한 위치를 찾을 필요가 없다.
불변성으로 인해 객체가 언제 어디서든 동일한 의미를 가진다고 확신할 수 있기 때문이다.
5. NULL 참조 없애기
NULL을 참조하는 객체는 언제 객체가 유효한 상태이고 언제 객체가 아닌 다른 형태로 바뀌는 지를 이해하기 어렵기 때문에 유지보수성이 저하될 수 밖에 없다.
불변 객체를 사용하면 NULL을 포함시키는 것이 애초에 불가능해진다.
작고, 견고하고, 응집도 높은 객체를 생성할 수 밖에 없도록 강제되기 때문에 결과적으로 유지보수하기 더 쉬운 객체를 만든다.
6. 스레드 안정성 → 여러 스레드에서 동시에 사용될 수 있으며 그 결과를 항상 예측가능하도록 유지할 수 있는 객체의 품질을 의미한다.
병행성 이슈는 발견하고 디버깅하고 해결하기 가장 어려운 문제 중 하나다.
불변 객체는 실행 시점에 상태를 수정할 수 없게 금지함으로써 이 문제를 완벽하게 해결한다.
7. 단순성
객체가 단순해질수록 응집도는 높아지고 유지보수하기는 더 쉬워진다.
대부분의 경우 단순하다는 것은 더 적은 코드 라인수를 의미한다.
저자가 생각하는 Java 클래스의 최대 크기는 주석과 공백을 포함해서 250줄 정도

## 7. 문서를 작성하는 대신 테스트를 만드세요

문서화는 유지보수에 있어 중요한 구성요소다.

단위 테스트는 클래스의 사용 방법을 보여주는데 반해, 문서는 이해하고 해석하기 어려운 이야기를 들려준다.

## 8. 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요

Mocking → 테스트를 최적화하기 위한 도구
Fake → 인터페이스의 일부이며 인터페이스와 함께 제공

Fake 클래스를 사용하면 테스트를 더 짧게 만들 수 있기 때문에 유지보수성이 향상된다.
Mocking은 테스트가 매우 장황해지고 이해하거나 리팩토링하기 어려워진다.

Mocking은 클래스 구현과 관련된 내부의 세부사항을 테스트와 결합시킨다. 가정하고, 가정을 모의 객체 안에 하드코딩한 채 작업을 끝내버린다.
Fake 클래스는 테스트를 충분히 유지보수 가능하게 만들 수 있다. 두 클래스 사이의 의사소통 방식에 대해서 신경쓸 필요가 없기 때문이다.

## 9. 인터페이스를 짧게 유지하고 스마트를 사용하세요

클래스가 다수의 인터페이스를 구현하기 때문에, 인터페이스를 작게 만드는 것이 클래스를 작게 만드는 것보다 더 중요하다.

인터페이스를 구현하는 서로 다른 클래스 안에 동일한 기능을 반복해서 구현하고 싶지 않을때, 스마트 클래스를 인터페이스와 함께 제공할 수 있다.