# 3장 취업

## 1. 5개 이하의 public 메소드만 노출하세요

클래스의 크기를 정하는 기준으로 코드 라인 수 이외에 public 메소드의 개수를 사용하기를 권장한다.
저자가 적절하다고 생각하는 public 메소드의 개수는 5개다.

클래스를 작게 만들면 유지보수성, 응집도, 테스트 용이성 등이 향상된다.

## 2. 정적 메소드를 사용하지 마세요

정적 메소드는 소프트웨어를 유지보수하기 어렵게 만든다.

1. 객체 대 컴퓨터 사고
컴퓨터 사고는 순차적인 사고방식을 의미한다. 
객체는 순차적인 로직 및 구현방식에는 관심이 없고 “이것은 무엇이다(is a)”라고 정의하는 것이 핵심이다.
2. 선언형 스타일 대 명령형 스타일
명령형 프로그래밍 → 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술, 바로 메소드 호출연산
선언형 프로그램밍 → 제어 흐름을 서술하지 않고 계산 로직을 표현, 객체 생성 후 메소드 호출로 연산
선언형 방식은 직접 성능 최적화가 가능하여 더 빠르고, 다형성을 적용할 수 있어서 결합도를 낮춰 유지보수가 쉬워지고 코드를 직관적으로 이해할 수 있다.
3. 유틸리티 클래스
클래스의 인스턴스가 생성되는 것을 방지하기 위해 private 생성자를 추가하는 것이 좋다.
정적 메소드를 설명하며 나열한 모든 단점들을 증폭시키기 때문에 사용하지 않는 것을 권장한다.
4. 싱글톤 패턴
유명한 디자인패턴이지만 사실 안티패턴이다.
싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다.
싱글톤의 장점은 setInstance가 가능하다는 점이다. 내부에 캡슐화된 정적 객체를 교체해서 전체 개념을 테스트할 수 있다. 유틸리티 클래스 안에는 객체가 존재하지 않기 때문에 어떤 것도 변경할 수 없다.
5. 함수형 프로그래밍
저자가 권장하는 방식에 따르면, 함수와 객체 사이에는 많은 부분이 유사해진다.
FP보다 OOP의 표현력이 더 뛰어나고 강력하다.
6. 조합 가능한 데코레이터
선언한 것 만으로도 이 객체가 무엇인지 설명할 수 있어야 한다.
객체들의 전체적인 행동은 내부에 캡슐화하고 있는 객체들에 의해 유도된다. 각 데코레이터는 내부에 캡슐화하고 있는 객체에 별도의 행동을 추가한다. 데코레이터의 상태는 내부에 캡슐화하고 있는 객체들의 상태와 동일하다.

## 3. 인자의 값으로 NULL을 절대 허용하지 마세요

NULL을 사용하는 것은 각각의 객체가 자신의 행동을 온전히 책임진다는 객체 패러다임과 상반된다.
NULL 여부를 체크함으로써 객체가 맡아야 하는 상당량의 책임을 뺏고있기 때문이다.

## 4. 충성스러우면서 불변이거나, 아니면 상수이거나

불변의 핵심은 객체가 살아있는 동안 상태가 변하지 않는다는 사실이다.

## 5. 절대 getter와 setter를 사용하지 마세요

자료 구조는 멤버에 직접 접근하지만, 객체는 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않는다. 게다가 멤버를 노출하지도 않는다. → 캡슐화

모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다.
특정 시점에 이해해야 하는 범위가 작을수록 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기도 쉬워진다.

getter, setter를 사용하면 OOP의 캡슐화 원칙을 손쉽게 위반할 수 있다.
겉으로는 메소드처럼 보이지만, 실제로는 우리가 데이터에 직접 접근하고 있다는 점이다.

getter/setter 안티패턴에서 유해한 부분은 두 접두사인 get, set이라는 사실이 중요하다.
dollars()는 가능하지만 getDollars()는 안된다는 것이다.
get 접두사가 붙으면 메소드를 통해 데이터가 표면에 완전히 드러나며 클래스의 모든 사용자가 이 데이터를 볼 수 있게된다.

## 6. 부 생성자 밖에서는 new를 사용하지 마세요

메소드 안에서 new 연산자를 사용하여 인스턴스를 생성하면, 하드코딩된 의존성 문제가 발생한다.
의존성을 끊기 위해 내부 코드를 변경할 수 밖에 없어진다.

new를 사용하여 인스턴스를 생성하는 것이 아닌 생성자를 통해 인스턴스를 받아서 사용하면,
의존성을 제어하는 주체가 해당 객체가 아닌 사용하는 우리 자신이 된다.
다시말해, 객체가 필요한 의존성을 직접 생성하는 대신 우리가 생성자를 통해 의존성을 주입한다.

주 생성자를 사용할 경우에는 객체와 협력하는 모든 의존성을 우리 스스로 완전히 제어할 수 있다.
부 생성자를 제외한 곳에서는 new를 사용하지 않으면, 객체들은 상호간에 충분히 분리되고 테스트 용이성과 유지보수성을 크게 향상시킬 수 있다.

## 7. 인트로스펙션과 캐스팅을 피하세요

런타임에 객체의 타입을 조사(introspect)하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적으로 좋지 않다.

instanceOf를 활용하는 인트로스펙션과 캐스팅은 모두 개념적인 측면에서는 객체의 역할을 뺏는 것이고, 기술적인 측면에서는 결합도를 높이는 것이기 때문에 지양해야 한다.